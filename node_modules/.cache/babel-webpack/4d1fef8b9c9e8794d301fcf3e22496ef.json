{"ast":null,"code":"/*! https://mths.be/punycode v1.3.2 by @mathias */\n;\n\n(function (root) {\n  /** Detect free variables */\n  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n  var freeModule = typeof module == 'object' && module && !module.nodeType && module;\n  var freeGlobal = typeof global == 'object' && global;\n\n  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\n    root = freeGlobal;\n  }\n  /**\r\n   * The `punycode` object.\r\n   * @name punycode\r\n   * @type Object\r\n   */\n\n\n  var punycode,\n\n  /** Highest positive signed 32-bit float value */\n  maxInt = 2147483647,\n      // aka. 0x7FFFFFFF or 2^31-1\n\n  /** Bootstring parameters */\n  base = 36,\n      tMin = 1,\n      tMax = 26,\n      skew = 38,\n      damp = 700,\n      initialBias = 72,\n      initialN = 128,\n      // 0x80\n  delimiter = '-',\n      // '\\x2D'\n\n  /** Regular expressions */\n  regexPunycode = /^xn--/,\n      regexNonASCII = /[^\\x20-\\x7E]/,\n      // unprintable ASCII chars + non-ASCII chars\n  regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g,\n      // RFC 3490 separators\n\n  /** Error messages */\n  errors = {\n    'overflow': 'Overflow: input needs wider integers to process',\n    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n    'invalid-input': 'Invalid input'\n  },\n\n  /** Convenience shortcuts */\n  baseMinusTMin = base - tMin,\n      floor = Math.floor,\n      stringFromCharCode = String.fromCharCode,\n\n  /** Temporary variable */\n  key;\n  /*--------------------------------------------------------------------------*/\n\n  /**\r\n   * A generic error utility function.\r\n   * @private\r\n   * @param {String} type The error type.\r\n   * @returns {Error} Throws a `RangeError` with the applicable error message.\r\n   */\n\n  function error(type) {\n    throw RangeError(errors[type]);\n  }\n  /**\r\n   * A generic `Array#map` utility function.\r\n   * @private\r\n   * @param {Array} array The array to iterate over.\r\n   * @param {Function} callback The function that gets called for every array\r\n   * item.\r\n   * @returns {Array} A new array of values returned by the callback function.\r\n   */\n\n\n  function map(array, fn) {\n    var length = array.length;\n    var result = [];\n\n    while (length--) {\n      result[length] = fn(array[length]);\n    }\n\n    return result;\n  }\n  /**\r\n   * A simple `Array#map`-like wrapper to work with domain name strings or email\r\n   * addresses.\r\n   * @private\r\n   * @param {String} domain The domain name or email address.\r\n   * @param {Function} callback The function that gets called for every\r\n   * character.\r\n   * @returns {Array} A new string of characters returned by the callback\r\n   * function.\r\n   */\n\n\n  function mapDomain(string, fn) {\n    var parts = string.split('@');\n    var result = '';\n\n    if (parts.length > 1) {\n      // In email addresses, only the domain name should be punycoded. Leave\n      // the local part (i.e. everything up to `@`) intact.\n      result = parts[0] + '@';\n      string = parts[1];\n    } // Avoid `split(regex)` for IE8 compatibility. See #17.\n\n\n    string = string.replace(regexSeparators, '\\x2E');\n    var labels = string.split('.');\n    var encoded = map(labels, fn).join('.');\n    return result + encoded;\n  }\n  /**\r\n   * Creates an array containing the numeric code points of each Unicode\r\n   * character in the string. While JavaScript uses UCS-2 internally,\r\n   * this function will convert a pair of surrogate halves (each of which\r\n   * UCS-2 exposes as separate characters) into a single code point,\r\n   * matching UTF-16.\r\n   * @see `punycode.ucs2.encode`\r\n   * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n   * @memberOf punycode.ucs2\r\n   * @name decode\r\n   * @param {String} string The Unicode input string (UCS-2).\r\n   * @returns {Array} The new array of code points.\r\n   */\n\n\n  function ucs2decode(string) {\n    var output = [],\n        counter = 0,\n        length = string.length,\n        value,\n        extra;\n\n    while (counter < length) {\n      value = string.charCodeAt(counter++);\n\n      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n        // high surrogate, and there is a next character\n        extra = string.charCodeAt(counter++);\n\n        if ((extra & 0xFC00) == 0xDC00) {\n          // low surrogate\n          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n        } else {\n          // unmatched surrogate; only append this code unit, in case the next\n          // code unit is the high surrogate of a surrogate pair\n          output.push(value);\n          counter--;\n        }\n      } else {\n        output.push(value);\n      }\n    }\n\n    return output;\n  }\n  /**\r\n   * Creates a string based on an array of numeric code points.\r\n   * @see `punycode.ucs2.decode`\r\n   * @memberOf punycode.ucs2\r\n   * @name encode\r\n   * @param {Array} codePoints The array of numeric code points.\r\n   * @returns {String} The new Unicode string (UCS-2).\r\n   */\n\n\n  function ucs2encode(array) {\n    return map(array, function (value) {\n      var output = '';\n\n      if (value > 0xFFFF) {\n        value -= 0x10000;\n        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n        value = 0xDC00 | value & 0x3FF;\n      }\n\n      output += stringFromCharCode(value);\n      return output;\n    }).join('');\n  }\n  /**\r\n   * Converts a basic code point into a digit/integer.\r\n   * @see `digitToBasic()`\r\n   * @private\r\n   * @param {Number} codePoint The basic numeric code point value.\r\n   * @returns {Number} The numeric value of a basic code point (for use in\r\n   * representing integers) in the range `0` to `base - 1`, or `base` if\r\n   * the code point does not represent a value.\r\n   */\n\n\n  function basicToDigit(codePoint) {\n    if (codePoint - 48 < 10) {\n      return codePoint - 22;\n    }\n\n    if (codePoint - 65 < 26) {\n      return codePoint - 65;\n    }\n\n    if (codePoint - 97 < 26) {\n      return codePoint - 97;\n    }\n\n    return base;\n  }\n  /**\r\n   * Converts a digit/integer into a basic code point.\r\n   * @see `basicToDigit()`\r\n   * @private\r\n   * @param {Number} digit The numeric value of a basic code point.\r\n   * @returns {Number} The basic code point whose value (when used for\r\n   * representing integers) is `digit`, which needs to be in the range\r\n   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\r\n   * used; else, the lowercase form is used. The behavior is undefined\r\n   * if `flag` is non-zero and `digit` has no uppercase form.\r\n   */\n\n\n  function digitToBasic(digit, flag) {\n    //  0..25 map to ASCII a..z or A..Z\n    // 26..35 map to ASCII 0..9\n    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n  }\n  /**\r\n   * Bias adaptation function as per section 3.4 of RFC 3492.\r\n   * http://tools.ietf.org/html/rfc3492#section-3.4\r\n   * @private\r\n   */\n\n\n  function adapt(delta, numPoints, firstTime) {\n    var k = 0;\n    delta = firstTime ? floor(delta / damp) : delta >> 1;\n    delta += floor(delta / numPoints);\n\n    for (; delta > baseMinusTMin * tMax >> 1; k += base) {\n      delta = floor(delta / baseMinusTMin);\n    }\n\n    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n  }\n  /**\r\n   * Converts a Punycode string of ASCII-only symbols to a string of Unicode\r\n   * symbols.\r\n   * @memberOf punycode\r\n   * @param {String} input The Punycode string of ASCII-only symbols.\r\n   * @returns {String} The resulting string of Unicode symbols.\r\n   */\n\n\n  function decode(input) {\n    // Don't use UCS-2\n    var output = [],\n        inputLength = input.length,\n        out,\n        i = 0,\n        n = initialN,\n        bias = initialBias,\n        basic,\n        j,\n        index,\n        oldi,\n        w,\n        k,\n        digit,\n        t,\n\n    /** Cached calculation results */\n    baseMinusT; // Handle the basic code points: let `basic` be the number of input code\n    // points before the last delimiter, or `0` if there is none, then copy\n    // the first basic code points to the output.\n\n    basic = input.lastIndexOf(delimiter);\n\n    if (basic < 0) {\n      basic = 0;\n    }\n\n    for (j = 0; j < basic; ++j) {\n      // if it's not a basic code point\n      if (input.charCodeAt(j) >= 0x80) {\n        error('not-basic');\n      }\n\n      output.push(input.charCodeAt(j));\n    } // Main decoding loop: start just after the last delimiter if any basic code\n    // points were copied; start at the beginning otherwise.\n\n\n    for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {\n      // `index` is the index of the next character to be consumed.\n      // Decode a generalized variable-length integer into `delta`,\n      // which gets added to `i`. The overflow checking is easier\n      // if we increase `i` as we go, then subtract off its starting\n      // value at the end to obtain `delta`.\n      for (oldi = i, w = 1, k = base;; k += base) {\n        if (index >= inputLength) {\n          error('invalid-input');\n        }\n\n        digit = basicToDigit(input.charCodeAt(index++));\n\n        if (digit >= base || digit > floor((maxInt - i) / w)) {\n          error('overflow');\n        }\n\n        i += digit * w;\n        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n        if (digit < t) {\n          break;\n        }\n\n        baseMinusT = base - t;\n\n        if (w > floor(maxInt / baseMinusT)) {\n          error('overflow');\n        }\n\n        w *= baseMinusT;\n      }\n\n      out = output.length + 1;\n      bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,\n      // incrementing `n` each time, so we'll fix that now:\n\n      if (floor(i / out) > maxInt - n) {\n        error('overflow');\n      }\n\n      n += floor(i / out);\n      i %= out; // Insert `n` at position `i` of the output\n\n      output.splice(i++, 0, n);\n    }\n\n    return ucs2encode(output);\n  }\n  /**\r\n   * Converts a string of Unicode symbols (e.g. a domain name label) to a\r\n   * Punycode string of ASCII-only symbols.\r\n   * @memberOf punycode\r\n   * @param {String} input The string of Unicode symbols.\r\n   * @returns {String} The resulting Punycode string of ASCII-only symbols.\r\n   */\n\n\n  function encode(input) {\n    var n,\n        delta,\n        handledCPCount,\n        basicLength,\n        bias,\n        j,\n        m,\n        q,\n        k,\n        t,\n        currentValue,\n        output = [],\n\n    /** `inputLength` will hold the number of code points in `input`. */\n    inputLength,\n\n    /** Cached calculation results */\n    handledCPCountPlusOne,\n        baseMinusT,\n        qMinusT; // Convert the input in UCS-2 to Unicode\n\n    input = ucs2decode(input); // Cache the length\n\n    inputLength = input.length; // Initialize the state\n\n    n = initialN;\n    delta = 0;\n    bias = initialBias; // Handle the basic code points\n\n    for (j = 0; j < inputLength; ++j) {\n      currentValue = input[j];\n\n      if (currentValue < 0x80) {\n        output.push(stringFromCharCode(currentValue));\n      }\n    }\n\n    handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;\n    // `basicLength` is the number of basic code points.\n    // Finish the basic string - if it is not empty - with a delimiter\n\n    if (basicLength) {\n      output.push(delimiter);\n    } // Main encoding loop:\n\n\n    while (handledCPCount < inputLength) {\n      // All non-basic code points < n have been handled already. Find the next\n      // larger one:\n      for (m = maxInt, j = 0; j < inputLength; ++j) {\n        currentValue = input[j];\n\n        if (currentValue >= n && currentValue < m) {\n          m = currentValue;\n        }\n      } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n      // but guard against overflow\n\n\n      handledCPCountPlusOne = handledCPCount + 1;\n\n      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n        error('overflow');\n      }\n\n      delta += (m - n) * handledCPCountPlusOne;\n      n = m;\n\n      for (j = 0; j < inputLength; ++j) {\n        currentValue = input[j];\n\n        if (currentValue < n && ++delta > maxInt) {\n          error('overflow');\n        }\n\n        if (currentValue == n) {\n          // Represent delta as a generalized variable-length integer\n          for (q = delta, k = base;; k += base) {\n            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n            if (q < t) {\n              break;\n            }\n\n            qMinusT = q - t;\n            baseMinusT = base - t;\n            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n            q = floor(qMinusT / baseMinusT);\n          }\n\n          output.push(stringFromCharCode(digitToBasic(q, 0)));\n          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n          delta = 0;\n          ++handledCPCount;\n        }\n      }\n\n      ++delta;\n      ++n;\n    }\n\n    return output.join('');\n  }\n  /**\r\n   * Converts a Punycode string representing a domain name or an email address\r\n   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\r\n   * it doesn't matter if you call it on a string that has already been\r\n   * converted to Unicode.\r\n   * @memberOf punycode\r\n   * @param {String} input The Punycoded domain name or email address to\r\n   * convert to Unicode.\r\n   * @returns {String} The Unicode representation of the given Punycode\r\n   * string.\r\n   */\n\n\n  function toUnicode(input) {\n    return mapDomain(input, function (string) {\n      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n    });\n  }\n  /**\r\n   * Converts a Unicode string representing a domain name or an email address to\r\n   * Punycode. Only the non-ASCII parts of the domain name will be converted,\r\n   * i.e. it doesn't matter if you call it with a domain that's already in\r\n   * ASCII.\r\n   * @memberOf punycode\r\n   * @param {String} input The domain name or email address to convert, as a\r\n   * Unicode string.\r\n   * @returns {String} The Punycode representation of the given domain name or\r\n   * email address.\r\n   */\n\n\n  function toASCII(input) {\n    return mapDomain(input, function (string) {\n      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n    });\n  }\n  /*--------------------------------------------------------------------------*/\n\n  /** Define the public API */\n\n\n  punycode = {\n    /**\r\n     * A string representing the current Punycode.js version number.\r\n     * @memberOf punycode\r\n     * @type String\r\n     */\n    'version': '1.3.2',\n\n    /**\r\n     * An object of methods to convert from JavaScript's internal character\r\n     * representation (UCS-2) to Unicode code points, and back.\r\n     * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n     * @memberOf punycode\r\n     * @type Object\r\n     */\n    'ucs2': {\n      'decode': ucs2decode,\n      'encode': ucs2encode\n    },\n    'decode': decode,\n    'encode': encode,\n    'toASCII': toASCII,\n    'toUnicode': toUnicode\n  };\n  /** Expose `punycode` */\n  // Some AMD build optimizers, like r.js, check for specific condition patterns\n  // like the following:\n\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    define('punycode', function () {\n      return punycode;\n    });\n  } else if (freeExports && freeModule) {\n    if (module.exports == freeExports) {\n      // in Node.js or RingoJS v0.8.0+\n      freeModule.exports = punycode;\n    } else {\n      // in Narwhal or RingoJS v0.7.0-\n      for (key in punycode) {\n        punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n      }\n    }\n  } else {\n    // in Rhino or a web browser\n    root.punycode = punycode;\n  }\n})(this);","map":{"version":3,"sources":["C:/Users/AdMin/Desktop/frontend/pferouandi/node_modules/url/node_modules/punycode/punycode.js"],"names":["root","freeExports","exports","nodeType","freeModule","module","freeGlobal","global","window","self","punycode","maxInt","base","tMin","tMax","skew","damp","initialBias","initialN","delimiter","regexPunycode","regexNonASCII","regexSeparators","errors","baseMinusTMin","floor","Math","stringFromCharCode","String","fromCharCode","key","error","type","RangeError","map","array","fn","length","result","mapDomain","string","parts","split","replace","labels","encoded","join","ucs2decode","output","counter","value","extra","charCodeAt","push","ucs2encode","basicToDigit","codePoint","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","k","decode","input","inputLength","out","i","n","bias","basic","j","index","oldi","w","t","baseMinusT","lastIndexOf","splice","encode","handledCPCount","basicLength","m","q","currentValue","handledCPCountPlusOne","qMinusT","toUnicode","test","slice","toLowerCase","toASCII","define","amd","hasOwnProperty"],"mappings":"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","sourcesContent":["/*! https://mths.be/punycode v1.3.2 by @mathias */\r\n;(function (root) {\r\n\r\n    /** Detect free variables */\r\n    var freeExports = typeof exports == 'object' && exports &&\r\n        !exports.nodeType && exports;\r\n    var freeModule = typeof module == 'object' && module &&\r\n        !module.nodeType && module;\r\n    var freeGlobal = typeof global == 'object' && global;\r\n    if (\r\n        freeGlobal.global === freeGlobal ||\r\n        freeGlobal.window === freeGlobal ||\r\n        freeGlobal.self === freeGlobal\r\n    ) {\r\n        root = freeGlobal;\r\n    }\r\n\r\n    /**\r\n     * The `punycode` object.\r\n     * @name punycode\r\n     * @type Object\r\n     */\r\n    var punycode,\r\n\r\n        /** Highest positive signed 32-bit float value */\r\n        maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\r\n\r\n        /** Bootstring parameters */\r\n        base = 36,\r\n        tMin = 1,\r\n        tMax = 26,\r\n        skew = 38,\r\n        damp = 700,\r\n        initialBias = 72,\r\n        initialN = 128, // 0x80\r\n        delimiter = '-', // '\\x2D'\r\n\r\n        /** Regular expressions */\r\n        regexPunycode = /^xn--/,\r\n        regexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\r\n        regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\r\n\r\n        /** Error messages */\r\n        errors = {\r\n            'overflow': 'Overflow: input needs wider integers to process',\r\n            'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\r\n            'invalid-input': 'Invalid input'\r\n        },\r\n\r\n        /** Convenience shortcuts */\r\n        baseMinusTMin = base - tMin,\r\n        floor = Math.floor,\r\n        stringFromCharCode = String.fromCharCode,\r\n\r\n        /** Temporary variable */\r\n        key;\r\n\r\n    /*--------------------------------------------------------------------------*/\r\n\r\n    /**\r\n     * A generic error utility function.\r\n     * @private\r\n     * @param {String} type The error type.\r\n     * @returns {Error} Throws a `RangeError` with the applicable error message.\r\n     */\r\n    function error(type) {\r\n        throw RangeError(errors[type]);\r\n    }\r\n\r\n    /**\r\n     * A generic `Array#map` utility function.\r\n     * @private\r\n     * @param {Array} array The array to iterate over.\r\n     * @param {Function} callback The function that gets called for every array\r\n     * item.\r\n     * @returns {Array} A new array of values returned by the callback function.\r\n     */\r\n    function map(array, fn) {\r\n        var length = array.length;\r\n        var result = [];\r\n        while (length--) {\r\n            result[length] = fn(array[length]);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * A simple `Array#map`-like wrapper to work with domain name strings or email\r\n     * addresses.\r\n     * @private\r\n     * @param {String} domain The domain name or email address.\r\n     * @param {Function} callback The function that gets called for every\r\n     * character.\r\n     * @returns {Array} A new string of characters returned by the callback\r\n     * function.\r\n     */\r\n    function mapDomain(string, fn) {\r\n        var parts = string.split('@');\r\n        var result = '';\r\n        if (parts.length > 1) {\r\n            // In email addresses, only the domain name should be punycoded. Leave\r\n            // the local part (i.e. everything up to `@`) intact.\r\n            result = parts[0] + '@';\r\n            string = parts[1];\r\n        }\r\n        // Avoid `split(regex)` for IE8 compatibility. See #17.\r\n        string = string.replace(regexSeparators, '\\x2E');\r\n        var labels = string.split('.');\r\n        var encoded = map(labels, fn).join('.');\r\n        return result + encoded;\r\n    }\r\n\r\n    /**\r\n     * Creates an array containing the numeric code points of each Unicode\r\n     * character in the string. While JavaScript uses UCS-2 internally,\r\n     * this function will convert a pair of surrogate halves (each of which\r\n     * UCS-2 exposes as separate characters) into a single code point,\r\n     * matching UTF-16.\r\n     * @see `punycode.ucs2.encode`\r\n     * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n     * @memberOf punycode.ucs2\r\n     * @name decode\r\n     * @param {String} string The Unicode input string (UCS-2).\r\n     * @returns {Array} The new array of code points.\r\n     */\r\n    function ucs2decode(string) {\r\n        var output = [],\r\n            counter = 0,\r\n            length = string.length,\r\n            value,\r\n            extra;\r\n        while (counter < length) {\r\n            value = string.charCodeAt(counter++);\r\n            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\r\n                // high surrogate, and there is a next character\r\n                extra = string.charCodeAt(counter++);\r\n                if ((extra & 0xFC00) == 0xDC00) { // low surrogate\r\n                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\r\n                } else {\r\n                    // unmatched surrogate; only append this code unit, in case the next\r\n                    // code unit is the high surrogate of a surrogate pair\r\n                    output.push(value);\r\n                    counter--;\r\n                }\r\n            } else {\r\n                output.push(value);\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * Creates a string based on an array of numeric code points.\r\n     * @see `punycode.ucs2.decode`\r\n     * @memberOf punycode.ucs2\r\n     * @name encode\r\n     * @param {Array} codePoints The array of numeric code points.\r\n     * @returns {String} The new Unicode string (UCS-2).\r\n     */\r\n    function ucs2encode(array) {\r\n        return map(array, function (value) {\r\n            var output = '';\r\n            if (value > 0xFFFF) {\r\n                value -= 0x10000;\r\n                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\r\n                value = 0xDC00 | value & 0x3FF;\r\n            }\r\n            output += stringFromCharCode(value);\r\n            return output;\r\n        }).join('');\r\n    }\r\n\r\n    /**\r\n     * Converts a basic code point into a digit/integer.\r\n     * @see `digitToBasic()`\r\n     * @private\r\n     * @param {Number} codePoint The basic numeric code point value.\r\n     * @returns {Number} The numeric value of a basic code point (for use in\r\n     * representing integers) in the range `0` to `base - 1`, or `base` if\r\n     * the code point does not represent a value.\r\n     */\r\n    function basicToDigit(codePoint) {\r\n        if (codePoint - 48 < 10) {\r\n            return codePoint - 22;\r\n        }\r\n        if (codePoint - 65 < 26) {\r\n            return codePoint - 65;\r\n        }\r\n        if (codePoint - 97 < 26) {\r\n            return codePoint - 97;\r\n        }\r\n        return base;\r\n    }\r\n\r\n    /**\r\n     * Converts a digit/integer into a basic code point.\r\n     * @see `basicToDigit()`\r\n     * @private\r\n     * @param {Number} digit The numeric value of a basic code point.\r\n     * @returns {Number} The basic code point whose value (when used for\r\n     * representing integers) is `digit`, which needs to be in the range\r\n     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\r\n     * used; else, the lowercase form is used. The behavior is undefined\r\n     * if `flag` is non-zero and `digit` has no uppercase form.\r\n     */\r\n    function digitToBasic(digit, flag) {\r\n        //  0..25 map to ASCII a..z or A..Z\r\n        // 26..35 map to ASCII 0..9\r\n        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\r\n    }\r\n\r\n    /**\r\n     * Bias adaptation function as per section 3.4 of RFC 3492.\r\n     * http://tools.ietf.org/html/rfc3492#section-3.4\r\n     * @private\r\n     */\r\n    function adapt(delta, numPoints, firstTime) {\r\n        var k = 0;\r\n        delta = firstTime ? floor(delta / damp) : delta >> 1;\r\n        delta += floor(delta / numPoints);\r\n        for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\r\n            delta = floor(delta / baseMinusTMin);\r\n        }\r\n        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\r\n    }\r\n\r\n    /**\r\n     * Converts a Punycode string of ASCII-only symbols to a string of Unicode\r\n     * symbols.\r\n     * @memberOf punycode\r\n     * @param {String} input The Punycode string of ASCII-only symbols.\r\n     * @returns {String} The resulting string of Unicode symbols.\r\n     */\r\n    function decode(input) {\r\n        // Don't use UCS-2\r\n        var output = [],\r\n            inputLength = input.length,\r\n            out,\r\n            i = 0,\r\n            n = initialN,\r\n            bias = initialBias,\r\n            basic,\r\n            j,\r\n            index,\r\n            oldi,\r\n            w,\r\n            k,\r\n            digit,\r\n            t,\r\n            /** Cached calculation results */\r\n            baseMinusT;\r\n\r\n        // Handle the basic code points: let `basic` be the number of input code\r\n        // points before the last delimiter, or `0` if there is none, then copy\r\n        // the first basic code points to the output.\r\n\r\n        basic = input.lastIndexOf(delimiter);\r\n        if (basic < 0) {\r\n            basic = 0;\r\n        }\r\n\r\n        for (j = 0; j < basic; ++j) {\r\n            // if it's not a basic code point\r\n            if (input.charCodeAt(j) >= 0x80) {\r\n                error('not-basic');\r\n            }\r\n            output.push(input.charCodeAt(j));\r\n        }\r\n\r\n        // Main decoding loop: start just after the last delimiter if any basic code\r\n        // points were copied; start at the beginning otherwise.\r\n\r\n        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\r\n\r\n            // `index` is the index of the next character to be consumed.\r\n            // Decode a generalized variable-length integer into `delta`,\r\n            // which gets added to `i`. The overflow checking is easier\r\n            // if we increase `i` as we go, then subtract off its starting\r\n            // value at the end to obtain `delta`.\r\n            for (oldi = i, w = 1, k = base; /* no condition */; k += base) {\r\n\r\n                if (index >= inputLength) {\r\n                    error('invalid-input');\r\n                }\r\n\r\n                digit = basicToDigit(input.charCodeAt(index++));\r\n\r\n                if (digit >= base || digit > floor((maxInt - i) / w)) {\r\n                    error('overflow');\r\n                }\r\n\r\n                i += digit * w;\r\n                t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\r\n\r\n                if (digit < t) {\r\n                    break;\r\n                }\r\n\r\n                baseMinusT = base - t;\r\n                if (w > floor(maxInt / baseMinusT)) {\r\n                    error('overflow');\r\n                }\r\n\r\n                w *= baseMinusT;\r\n\r\n            }\r\n\r\n            out = output.length + 1;\r\n            bias = adapt(i - oldi, out, oldi == 0);\r\n\r\n            // `i` was supposed to wrap around from `out` to `0`,\r\n            // incrementing `n` each time, so we'll fix that now:\r\n            if (floor(i / out) > maxInt - n) {\r\n                error('overflow');\r\n            }\r\n\r\n            n += floor(i / out);\r\n            i %= out;\r\n\r\n            // Insert `n` at position `i` of the output\r\n            output.splice(i++, 0, n);\r\n\r\n        }\r\n\r\n        return ucs2encode(output);\r\n    }\r\n\r\n    /**\r\n     * Converts a string of Unicode symbols (e.g. a domain name label) to a\r\n     * Punycode string of ASCII-only symbols.\r\n     * @memberOf punycode\r\n     * @param {String} input The string of Unicode symbols.\r\n     * @returns {String} The resulting Punycode string of ASCII-only symbols.\r\n     */\r\n    function encode(input) {\r\n        var n,\r\n            delta,\r\n            handledCPCount,\r\n            basicLength,\r\n            bias,\r\n            j,\r\n            m,\r\n            q,\r\n            k,\r\n            t,\r\n            currentValue,\r\n            output = [],\r\n            /** `inputLength` will hold the number of code points in `input`. */\r\n            inputLength,\r\n            /** Cached calculation results */\r\n            handledCPCountPlusOne,\r\n            baseMinusT,\r\n            qMinusT;\r\n\r\n        // Convert the input in UCS-2 to Unicode\r\n        input = ucs2decode(input);\r\n\r\n        // Cache the length\r\n        inputLength = input.length;\r\n\r\n        // Initialize the state\r\n        n = initialN;\r\n        delta = 0;\r\n        bias = initialBias;\r\n\r\n        // Handle the basic code points\r\n        for (j = 0; j < inputLength; ++j) {\r\n            currentValue = input[j];\r\n            if (currentValue < 0x80) {\r\n                output.push(stringFromCharCode(currentValue));\r\n            }\r\n        }\r\n\r\n        handledCPCount = basicLength = output.length;\r\n\r\n        // `handledCPCount` is the number of code points that have been handled;\r\n        // `basicLength` is the number of basic code points.\r\n\r\n        // Finish the basic string - if it is not empty - with a delimiter\r\n        if (basicLength) {\r\n            output.push(delimiter);\r\n        }\r\n\r\n        // Main encoding loop:\r\n        while (handledCPCount < inputLength) {\r\n\r\n            // All non-basic code points < n have been handled already. Find the next\r\n            // larger one:\r\n            for (m = maxInt, j = 0; j < inputLength; ++j) {\r\n                currentValue = input[j];\r\n                if (currentValue >= n && currentValue < m) {\r\n                    m = currentValue;\r\n                }\r\n            }\r\n\r\n            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\r\n            // but guard against overflow\r\n            handledCPCountPlusOne = handledCPCount + 1;\r\n            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\r\n                error('overflow');\r\n            }\r\n\r\n            delta += (m - n) * handledCPCountPlusOne;\r\n            n = m;\r\n\r\n            for (j = 0; j < inputLength; ++j) {\r\n                currentValue = input[j];\r\n\r\n                if (currentValue < n && ++delta > maxInt) {\r\n                    error('overflow');\r\n                }\r\n\r\n                if (currentValue == n) {\r\n                    // Represent delta as a generalized variable-length integer\r\n                    for (q = delta, k = base; /* no condition */; k += base) {\r\n                        t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\r\n                        if (q < t) {\r\n                            break;\r\n                        }\r\n                        qMinusT = q - t;\r\n                        baseMinusT = base - t;\r\n                        output.push(\r\n                            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\r\n                        );\r\n                        q = floor(qMinusT / baseMinusT);\r\n                    }\r\n\r\n                    output.push(stringFromCharCode(digitToBasic(q, 0)));\r\n                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\r\n                    delta = 0;\r\n                    ++handledCPCount;\r\n                }\r\n            }\r\n\r\n            ++delta;\r\n            ++n;\r\n\r\n        }\r\n        return output.join('');\r\n    }\r\n\r\n    /**\r\n     * Converts a Punycode string representing a domain name or an email address\r\n     * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\r\n     * it doesn't matter if you call it on a string that has already been\r\n     * converted to Unicode.\r\n     * @memberOf punycode\r\n     * @param {String} input The Punycoded domain name or email address to\r\n     * convert to Unicode.\r\n     * @returns {String} The Unicode representation of the given Punycode\r\n     * string.\r\n     */\r\n    function toUnicode(input) {\r\n        return mapDomain(input, function (string) {\r\n            return regexPunycode.test(string)\r\n                ? decode(string.slice(4).toLowerCase())\r\n                : string;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts a Unicode string representing a domain name or an email address to\r\n     * Punycode. Only the non-ASCII parts of the domain name will be converted,\r\n     * i.e. it doesn't matter if you call it with a domain that's already in\r\n     * ASCII.\r\n     * @memberOf punycode\r\n     * @param {String} input The domain name or email address to convert, as a\r\n     * Unicode string.\r\n     * @returns {String} The Punycode representation of the given domain name or\r\n     * email address.\r\n     */\r\n    function toASCII(input) {\r\n        return mapDomain(input, function (string) {\r\n            return regexNonASCII.test(string)\r\n                ? 'xn--' + encode(string)\r\n                : string;\r\n        });\r\n    }\r\n\r\n    /*--------------------------------------------------------------------------*/\r\n\r\n    /** Define the public API */\r\n    punycode = {\r\n        /**\r\n         * A string representing the current Punycode.js version number.\r\n         * @memberOf punycode\r\n         * @type String\r\n         */\r\n        'version': '1.3.2',\r\n        /**\r\n         * An object of methods to convert from JavaScript's internal character\r\n         * representation (UCS-2) to Unicode code points, and back.\r\n         * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n         * @memberOf punycode\r\n         * @type Object\r\n         */\r\n        'ucs2': {\r\n            'decode': ucs2decode,\r\n            'encode': ucs2encode\r\n        },\r\n        'decode': decode,\r\n        'encode': encode,\r\n        'toASCII': toASCII,\r\n        'toUnicode': toUnicode\r\n    };\r\n\r\n    /** Expose `punycode` */\r\n    // Some AMD build optimizers, like r.js, check for specific condition patterns\r\n    // like the following:\r\n    if (\r\n        typeof define == 'function' &&\r\n        typeof define.amd == 'object' &&\r\n        define.amd\r\n    ) {\r\n        define('punycode', function () {\r\n            return punycode;\r\n        });\r\n    } else if (freeExports && freeModule) {\r\n        if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+\r\n            freeModule.exports = punycode;\r\n        } else { // in Narwhal or RingoJS v0.7.0-\r\n            for (key in punycode) {\r\n                punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\r\n            }\r\n        }\r\n    } else { // in Rhino or a web browser\r\n        root.punycode = punycode;\r\n    }\r\n\r\n}(this));\r\n"]},"metadata":{},"sourceType":"script"}