{"ast":null,"code":"import { tokenRegex, revFormat, formats } from \"./formatting\";\nimport { defaults } from \"../types/options\";\nimport { english } from \"../l10n/default\";\nexport var createDateFormatter = function createDateFormatter(_ref) {\n  var _ref$config = _ref.config,\n      config = _ref$config === void 0 ? defaults : _ref$config,\n      _ref$l10n = _ref.l10n,\n      l10n = _ref$l10n === void 0 ? english : _ref$l10n,\n      _ref$isMobile = _ref.isMobile,\n      isMobile = _ref$isMobile === void 0 ? false : _ref$isMobile;\n  return function (dateObj, frmt, overrideLocale) {\n    var locale = overrideLocale || l10n;\n\n    if (config.formatDate !== undefined && !isMobile) {\n      return config.formatDate(dateObj, frmt, locale);\n    }\n\n    return frmt.split(\"\").map(function (c, i, arr) {\n      return formats[c] && arr[i - 1] !== \"\\\\\" ? formats[c](dateObj, locale, config) : c !== \"\\\\\" ? c : \"\";\n    }).join(\"\");\n  };\n};\nexport var createDateParser = function createDateParser(_ref2) {\n  var _ref2$config = _ref2.config,\n      config = _ref2$config === void 0 ? defaults : _ref2$config,\n      _ref2$l10n = _ref2.l10n,\n      l10n = _ref2$l10n === void 0 ? english : _ref2$l10n;\n  return function (date, givenFormat, timeless, customLocale) {\n    if (date !== 0 && !date) return undefined;\n    var locale = customLocale || l10n;\n    var parsedDate;\n    var dateOrig = date;\n    if (date instanceof Date) parsedDate = new Date(date.getTime());else if (typeof date !== \"string\" && date.toFixed !== undefined) parsedDate = new Date(date);else if (typeof date === \"string\") {\n      var format = givenFormat || (config || defaults).dateFormat;\n      var datestr = String(date).trim();\n\n      if (datestr === \"today\") {\n        parsedDate = new Date();\n        timeless = true;\n      } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) parsedDate = new Date(date);else if (config && config.parseDate) parsedDate = config.parseDate(date, format);else {\n        parsedDate = !config || !config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));\n        var matched,\n            ops = [];\n\n        for (var i = 0, matchIndex = 0, regexStr = \"\"; i < format.length; i++) {\n          var token = format[i];\n          var isBackSlash = token === \"\\\\\";\n          var escaped = format[i - 1] === \"\\\\\" || isBackSlash;\n\n          if (tokenRegex[token] && !escaped) {\n            regexStr += tokenRegex[token];\n            var match = new RegExp(regexStr).exec(date);\n\n            if (match && (matched = true)) {\n              ops[token !== \"Y\" ? \"push\" : \"unshift\"]({\n                fn: revFormat[token],\n                val: match[++matchIndex]\n              });\n            }\n          } else if (!isBackSlash) regexStr += \".\";\n\n          ops.forEach(function (_ref3) {\n            var fn = _ref3.fn,\n                val = _ref3.val;\n            return parsedDate = fn(parsedDate, val, locale) || parsedDate;\n          });\n        }\n\n        parsedDate = matched ? parsedDate : undefined;\n      }\n    }\n\n    if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {\n      config.errorHandler(new Error(\"Invalid date provided: \".concat(dateOrig)));\n      return undefined;\n    }\n\n    if (timeless === true) parsedDate.setHours(0, 0, 0, 0);\n    return parsedDate;\n  };\n};\nexport function compareDates(date1, date2) {\n  var timeless = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  if (timeless !== false) {\n    return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);\n  }\n\n  return date1.getTime() - date2.getTime();\n}\nexport function compareTimes(date1, date2) {\n  return 3600 * (date1.getHours() - date2.getHours()) + 60 * (date1.getMinutes() - date2.getMinutes()) + date1.getSeconds() - date2.getSeconds();\n}\nexport var isBetween = function isBetween(ts, ts1, ts2) {\n  return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);\n};\nexport var duration = {\n  DAY: 86400000\n};\nexport function getDefaultHours(config) {\n  var hours = config.defaultHour;\n  var minutes = config.defaultMinute;\n  var seconds = config.defaultSeconds;\n\n  if (config.minDate !== undefined) {\n    var minHour = config.minDate.getHours();\n    var minMinutes = config.minDate.getMinutes();\n    var minSeconds = config.minDate.getSeconds();\n\n    if (hours < minHour) {\n      hours = minHour;\n    }\n\n    if (hours === minHour && minutes < minMinutes) {\n      minutes = minMinutes;\n    }\n\n    if (hours === minHour && minutes === minMinutes && seconds < minSeconds) seconds = config.minDate.getSeconds();\n  }\n\n  if (config.maxDate !== undefined) {\n    var maxHr = config.maxDate.getHours();\n    var maxMinutes = config.maxDate.getMinutes();\n    hours = Math.min(hours, maxHr);\n    if (hours === maxHr) minutes = Math.min(maxMinutes, minutes);\n    if (hours === maxHr && minutes === maxMinutes) seconds = config.maxDate.getSeconds();\n  }\n\n  return {\n    hours: hours,\n    minutes: minutes,\n    seconds: seconds\n  };\n}","map":{"version":3,"sources":["C:/Users/AdMin/Desktop/frontend/pferouandi/node_modules/flatpickr/dist/esm/utils/dates.js"],"names":["tokenRegex","revFormat","formats","defaults","english","createDateFormatter","config","l10n","isMobile","dateObj","frmt","overrideLocale","locale","formatDate","undefined","split","map","c","i","arr","join","createDateParser","date","givenFormat","timeless","customLocale","parsedDate","dateOrig","Date","getTime","toFixed","format","dateFormat","datestr","String","trim","test","parseDate","noCalendar","getFullYear","setHours","matched","ops","matchIndex","regexStr","length","token","isBackSlash","escaped","match","RegExp","exec","fn","val","forEach","isNaN","errorHandler","Error","compareDates","date1","date2","compareTimes","getHours","getMinutes","getSeconds","isBetween","ts","ts1","ts2","Math","min","max","duration","DAY","getDefaultHours","hours","defaultHour","minutes","defaultMinute","seconds","defaultSeconds","minDate","minHour","minMinutes","minSeconds","maxDate","maxHr","maxMinutes"],"mappings":"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","sourcesContent":["import { tokenRegex, revFormat, formats, } from \"./formatting\";\r\nimport { defaults } from \"../types/options\";\r\nimport { english } from \"../l10n/default\";\r\nexport const createDateFormatter = ({ config = defaults, l10n = english, isMobile = false, }) => (dateObj, frmt, overrideLocale) => {\r\n    const locale = overrideLocale || l10n;\r\n    if (config.formatDate !== undefined && !isMobile) {\r\n        return config.formatDate(dateObj, frmt, locale);\r\n    }\r\n    return frmt\r\n        .split(\"\")\r\n        .map((c, i, arr) => formats[c] && arr[i - 1] !== \"\\\\\"\r\n        ? formats[c](dateObj, locale, config)\r\n        : c !== \"\\\\\"\r\n            ? c\r\n            : \"\")\r\n        .join(\"\");\r\n};\r\nexport const createDateParser = ({ config = defaults, l10n = english }) => (date, givenFormat, timeless, customLocale) => {\r\n    if (date !== 0 && !date)\r\n        return undefined;\r\n    const locale = customLocale || l10n;\r\n    let parsedDate;\r\n    const dateOrig = date;\r\n    if (date instanceof Date)\r\n        parsedDate = new Date(date.getTime());\r\n    else if (typeof date !== \"string\" &&\r\n        date.toFixed !== undefined)\r\n        parsedDate = new Date(date);\r\n    else if (typeof date === \"string\") {\r\n        const format = givenFormat || (config || defaults).dateFormat;\r\n        const datestr = String(date).trim();\r\n        if (datestr === \"today\") {\r\n            parsedDate = new Date();\r\n            timeless = true;\r\n        }\r\n        else if (/Z$/.test(datestr) ||\r\n            /GMT$/.test(datestr))\r\n            parsedDate = new Date(date);\r\n        else if (config && config.parseDate)\r\n            parsedDate = config.parseDate(date, format);\r\n        else {\r\n            parsedDate =\r\n                !config || !config.noCalendar\r\n                    ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0)\r\n                    : new Date(new Date().setHours(0, 0, 0, 0));\r\n            let matched, ops = [];\r\n            for (let i = 0, matchIndex = 0, regexStr = \"\"; i < format.length; i++) {\r\n                const token = format[i];\r\n                const isBackSlash = token === \"\\\\\";\r\n                const escaped = format[i - 1] === \"\\\\\" || isBackSlash;\r\n                if (tokenRegex[token] && !escaped) {\r\n                    regexStr += tokenRegex[token];\r\n                    const match = new RegExp(regexStr).exec(date);\r\n                    if (match && (matched = true)) {\r\n                        ops[token !== \"Y\" ? \"push\" : \"unshift\"]({\r\n                            fn: revFormat[token],\r\n                            val: match[++matchIndex],\r\n                        });\r\n                    }\r\n                }\r\n                else if (!isBackSlash)\r\n                    regexStr += \".\";\r\n                ops.forEach(({ fn, val }) => (parsedDate = fn(parsedDate, val, locale) || parsedDate));\r\n            }\r\n            parsedDate = matched ? parsedDate : undefined;\r\n        }\r\n    }\r\n    if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {\r\n        config.errorHandler(new Error(`Invalid date provided: ${dateOrig}`));\r\n        return undefined;\r\n    }\r\n    if (timeless === true)\r\n        parsedDate.setHours(0, 0, 0, 0);\r\n    return parsedDate;\r\n};\r\nexport function compareDates(date1, date2, timeless = true) {\r\n    if (timeless !== false) {\r\n        return (new Date(date1.getTime()).setHours(0, 0, 0, 0) -\r\n            new Date(date2.getTime()).setHours(0, 0, 0, 0));\r\n    }\r\n    return date1.getTime() - date2.getTime();\r\n}\r\nexport function compareTimes(date1, date2) {\r\n    return (3600 * (date1.getHours() - date2.getHours()) +\r\n        60 * (date1.getMinutes() - date2.getMinutes()) +\r\n        date1.getSeconds() -\r\n        date2.getSeconds());\r\n}\r\nexport const isBetween = (ts, ts1, ts2) => {\r\n    return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);\r\n};\r\nexport const duration = {\r\n    DAY: 86400000,\r\n};\r\nexport function getDefaultHours(config) {\r\n    let hours = config.defaultHour;\r\n    let minutes = config.defaultMinute;\r\n    let seconds = config.defaultSeconds;\r\n    if (config.minDate !== undefined) {\r\n        const minHour = config.minDate.getHours();\r\n        const minMinutes = config.minDate.getMinutes();\r\n        const minSeconds = config.minDate.getSeconds();\r\n        if (hours < minHour) {\r\n            hours = minHour;\r\n        }\r\n        if (hours === minHour && minutes < minMinutes) {\r\n            minutes = minMinutes;\r\n        }\r\n        if (hours === minHour && minutes === minMinutes && seconds < minSeconds)\r\n            seconds = config.minDate.getSeconds();\r\n    }\r\n    if (config.maxDate !== undefined) {\r\n        const maxHr = config.maxDate.getHours();\r\n        const maxMinutes = config.maxDate.getMinutes();\r\n        hours = Math.min(hours, maxHr);\r\n        if (hours === maxHr)\r\n            minutes = Math.min(maxMinutes, minutes);\r\n        if (hours === maxHr && minutes === maxMinutes)\r\n            seconds = config.maxDate.getSeconds();\r\n    }\r\n    return { hours, minutes, seconds };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}